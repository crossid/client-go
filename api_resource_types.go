/*
Crossid API

# Introduction  Crossid API allows you to manage resources in a simple, programmatic way using conventional HTTP requests.  All of the functionality that you are familiar with in the Crossid UI is also available through this API, allowing you to code actions that suites your requirements.  The rest of this page provides a general overview about the API design and technology that has been implemented.  ## Requests  ## HTTP Statuses  ## Meta  ### Sample Links Object  ## Rate Limit  ## Curl Examples  ## OpenAPI Specification  Crossid API conforms the OpenAPI V3 specification.  The goal of The OpenAPI Specification is to define a standard, language-agnostic interface to REST APIs which  allows both humans and computers to discover and understand the capabilities of the service without access to source  code, documentation, or through network traffic inspection. When properly defined via OpenAPI, a consumer can  understand and interact with the remote service with a minimal amount of implementation logic. Similar to what  interfaces have done for lower-level programming, OpenAPI removes the guesswork in calling the service. 

API version: 2.0.0
Contact: api-engineering@crossid.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package cidclient

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
	"reflect"
	"time"
)

// Linger please
var (
	_ _context.Context
)

// ResourceTypesApiService ResourceTypesApi service
type ResourceTypesApiService service

type ApiCreateResourceTypeRequest struct {
	ctx _context.Context
	ApiService *ResourceTypesApiService
	reason *string
	resourceType *ResourceType
}

// A descriptive reason of the change
func (r ApiCreateResourceTypeRequest) Reason(reason string) ApiCreateResourceTypeRequest {
	r.reason = &reason
	return r
}
// A Resource Type in JSON format.
func (r ApiCreateResourceTypeRequest) ResourceType(resourceType ResourceType) ApiCreateResourceTypeRequest {
	r.resourceType = &resourceType
	return r
}

func (r ApiCreateResourceTypeRequest) Execute() (ResourceType, *_nethttp.Response, error) {
	return r.ApiService.CreateResourceTypeExecute(r)
}

/*
CreateResourceType Create a new Resource Type

Create a new Resource Type with the given payload.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateResourceTypeRequest
*/
func (a *ResourceTypesApiService) CreateResourceType(ctx _context.Context) ApiCreateResourceTypeRequest {
	return ApiCreateResourceTypeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ResourceType
func (a *ResourceTypesApiService) CreateResourceTypeExecute(r ApiCreateResourceTypeRequest) (ResourceType, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  ResourceType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceTypesApiService.CreateResourceType")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/resource-types"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.reason == nil {
		return localVarReturnValue, nil, reportError("reason is required and must be specified")
	}

	localVarQueryParams.Add("reason", parameterToString(*r.reason, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.resourceType
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetResourceTypeRequest struct {
	ctx _context.Context
	ApiService *ResourceTypesApiService
	id string
}


func (r ApiGetResourceTypeRequest) Execute() (ResourceType, *_nethttp.Response, error) {
	return r.ApiService.GetResourceTypeExecute(r)
}

/*
GetResourceType Retrieve an existing Resource Type.

Retrieve details about an existing Resource Type by its id.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The resource type ID
 @return ApiGetResourceTypeRequest
*/
func (a *ResourceTypesApiService) GetResourceType(ctx _context.Context, id string) ApiGetResourceTypeRequest {
	return ApiGetResourceTypeRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ResourceType
func (a *ResourceTypesApiService) GetResourceTypeExecute(r ApiGetResourceTypeRequest) (ResourceType, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  ResourceType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceTypesApiService.GetResourceType")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/resource-types/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListResourceTypesRequest struct {
	ctx _context.Context
	ApiService *ResourceTypesApiService
	filter *string
	count *int64
	startIndex *int64
	sortBy *string
	sortOrder *string
	attributes *[]string
	excludedAttributes *[]string
	forTime *time.Time
}

// The filter string used to request a subset of models. 
func (r ApiListResourceTypesRequest) Filter(filter string) ApiListResourceTypesRequest {
	r.filter = &filter
	return r
}
// The desired maximum number of query results per page, e.g., 10. A negative value is interpreted as \&quot;0\&quot;. A value of \&quot;0\&quot; indicates that no model results are to be returned except for \&quot;totalResults\&quot;. 
func (r ApiListResourceTypesRequest) Count(count int64) ApiListResourceTypesRequest {
	r.count = &count
	return r
}
// The 1-based index of the first query result. A value less than 1 SHALL be interpreted as 1. 
func (r ApiListResourceTypesRequest) StartIndex(startIndex int64) ApiListResourceTypesRequest {
	r.startIndex = &startIndex
	return r
}
// A string indicating the attribute whose value SHALL be used to order the returned responses.
func (r ApiListResourceTypesRequest) SortBy(sortBy string) ApiListResourceTypesRequest {
	r.sortBy = &sortBy
	return r
}
// A string indicating the order in which the \&quot;sortBy\&quot; parameter is applied.  Allowed values are \&quot;ascending\&quot; and \&quot;descending\&quot;.
func (r ApiListResourceTypesRequest) SortOrder(sortOrder string) ApiListResourceTypesRequest {
	r.sortOrder = &sortOrder
	return r
}
// A multi-valued list of strings indicating the names of resource attributes to return in the response, overriding the set of attributes that would be returned by default. 
func (r ApiListResourceTypesRequest) Attributes(attributes []string) ApiListResourceTypesRequest {
	r.attributes = &attributes
	return r
}
// A multi-valued list of strings indicating the names of resource attributes to be removed from the default set of attributes to return.  This parameter SHALL have no effect on attributes whose schema \&quot;returned\&quot; setting is \&quot;always\&quot;. 
func (r ApiListResourceTypesRequest) ExcludedAttributes(excludedAttributes []string) ApiListResourceTypesRequest {
	r.excludedAttributes = &excludedAttributes
	return r
}
// a date time indicating that the requested resources should be retrieved from history as how they looked for the specified time. 
func (r ApiListResourceTypesRequest) ForTime(forTime time.Time) ApiListResourceTypesRequest {
	r.forTime = &forTime
	return r
}

func (r ApiListResourceTypesRequest) Execute() (ResourceTypeList, *_nethttp.Response, error) {
	return r.ApiService.ListResourceTypesExecute(r)
}

/*
ListResourceTypes List existing Resource Types.

Retrieve a list of existing Resource Types.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListResourceTypesRequest
*/
func (a *ResourceTypesApiService) ListResourceTypes(ctx _context.Context) ApiListResourceTypesRequest {
	return ApiListResourceTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ResourceTypeList
func (a *ResourceTypesApiService) ListResourceTypesExecute(r ApiListResourceTypesRequest) (ResourceTypeList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  ResourceTypeList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceTypesApiService.ListResourceTypes")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/resource-types"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.filter != nil {
		localVarQueryParams.Add("filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("count", parameterToString(*r.count, ""))
	}
	if r.startIndex != nil {
		localVarQueryParams.Add("startIndex", parameterToString(*r.startIndex, ""))
	}
	if r.sortBy != nil {
		localVarQueryParams.Add("sortBy", parameterToString(*r.sortBy, ""))
	}
	if r.sortOrder != nil {
		localVarQueryParams.Add("sortOrder", parameterToString(*r.sortOrder, ""))
	}
	if r.attributes != nil {
		t := *r.attributes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("attributes", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("attributes", parameterToString(t, "multi"))
		}
	}
	if r.excludedAttributes != nil {
		t := *r.excludedAttributes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("excludedAttributes", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("excludedAttributes", parameterToString(t, "multi"))
		}
	}
	if r.forTime != nil {
		localVarQueryParams.Add("forTime", parameterToString(*r.forTime, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplaceResourceTypeRequest struct {
	ctx _context.Context
	ApiService *ResourceTypesApiService
	id string
	reason *string
	resourceType *ResourceType
}

// A descriptive reason of the change
func (r ApiReplaceResourceTypeRequest) Reason(reason string) ApiReplaceResourceTypeRequest {
	r.reason = &reason
	return r
}
// A Resource Type in JSON format.
func (r ApiReplaceResourceTypeRequest) ResourceType(resourceType ResourceType) ApiReplaceResourceTypeRequest {
	r.resourceType = &resourceType
	return r
}

func (r ApiReplaceResourceTypeRequest) Execute() (ResourceType, *_nethttp.Response, error) {
	return r.ApiService.ReplaceResourceTypeExecute(r)
}

/*
ReplaceResourceType Replace an existing Resource Type

Replace an existing Resource Type with the given payload.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The resource type ID
 @return ApiReplaceResourceTypeRequest
*/
func (a *ResourceTypesApiService) ReplaceResourceType(ctx _context.Context, id string) ApiReplaceResourceTypeRequest {
	return ApiReplaceResourceTypeRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ResourceType
func (a *ResourceTypesApiService) ReplaceResourceTypeExecute(r ApiReplaceResourceTypeRequest) (ResourceType, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  ResourceType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceTypesApiService.ReplaceResourceType")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/resource-types/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.reason == nil {
		return localVarReturnValue, nil, reportError("reason is required and must be specified")
	}

	localVarQueryParams.Add("reason", parameterToString(*r.reason, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.resourceType
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
