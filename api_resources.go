/*
Crossid API

# Introduction  Crossid API allows you to manage resources in a simple, programmatic way using conventional HTTP requests.  All of the functionality that you are familiar with in the Crossid UI is also available through this API, allowing you to code actions that suites your requirements.  The rest of this page provides a general overview about the API design and technology that has been implemented.  ## Requests  ## HTTP Statuses  ## Meta  ### Sample Links Object  ## Rate Limit  ## Curl Examples  ## OpenAPI Specification  Crossid API conforms the OpenAPI V3 specification.  The goal of The OpenAPI Specification is to define a standard, language-agnostic interface to REST APIs which  allows both humans and computers to discover and understand the capabilities of the service without access to source  code, documentation, or through network traffic inspection. When properly defined via OpenAPI, a consumer can  understand and interact with the remote service with a minimal amount of implementation logic. Similar to what  interfaces have done for lower-level programming, OpenAPI removes the guesswork in calling the service. 

API version: 2.0.0
Contact: api-engineering@crossid.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package cidclient

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
	"reflect"
	"time"
)

// Linger please
var (
	_ _context.Context
)

// ResourcesApiService ResourcesApi service
type ResourcesApiService service

type ApiCreateResourceRequest struct {
	ctx _context.Context
	ApiService *ResourcesApiService
	appId string
	resourceTypes string
	reason *string
	correlation *string
	resource *Resource
}

// A descriptive reason of the change
func (r ApiCreateResourceRequest) Reason(reason string) ApiCreateResourceRequest {
	r.reason = &reason
	return r
}
// a unique identifier of an external resource where this change should be correlated to 
func (r ApiCreateResourceRequest) Correlation(correlation string) ApiCreateResourceRequest {
	r.correlation = &correlation
	return r
}
// A Resource, in JSON format.
func (r ApiCreateResourceRequest) Resource(resource Resource) ApiCreateResourceRequest {
	r.resource = &resource
	return r
}

func (r ApiCreateResourceRequest) Execute() (Resource, *_nethttp.Response, error) {
	return r.ApiService.CreateResourceExecute(r)
}

/*
CreateResource Create a new Resource

Create a new Resource with the given payload.
Each resource has some type (e.g., User) in some App.

The resource may be created locally on store or provisioned to the remote app, depends on application configuration.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appId The app ID that owns the resources
 @param resourceTypes The resource types
 @return ApiCreateResourceRequest
*/
func (a *ResourcesApiService) CreateResource(ctx _context.Context, appId string, resourceTypes string) ApiCreateResourceRequest {
	return ApiCreateResourceRequest{
		ApiService: a,
		ctx: ctx,
		appId: appId,
		resourceTypes: resourceTypes,
	}
}

// Execute executes the request
//  @return Resource
func (a *ResourcesApiService) CreateResourceExecute(r ApiCreateResourceRequest) (Resource, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  Resource
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourcesApiService.CreateResource")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/resources/{appId}/{resourceTypes}"
	localVarPath = strings.Replace(localVarPath, "{"+"appId"+"}", _neturl.PathEscape(parameterToString(r.appId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"resourceTypes"+"}", _neturl.PathEscape(parameterToString(r.resourceTypes, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.reason == nil {
		return localVarReturnValue, nil, reportError("reason is required and must be specified")
	}

	localVarQueryParams.Add("reason", parameterToString(*r.reason, ""))
	if r.correlation != nil {
		localVarQueryParams.Add("correlation", parameterToString(*r.correlation, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.resource
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListResourcesOfTypeRequest struct {
	ctx _context.Context
	ApiService *ResourcesApiService
	appId string
	resourceTypes string
	filter *string
	count *int64
	startIndex *int64
	sortBy *string
	sortOrder *string
	attributes *[]string
	excludedAttributes *[]string
	forTime *time.Time
}

// The filter string used to request a subset of models. 
func (r ApiListResourcesOfTypeRequest) Filter(filter string) ApiListResourcesOfTypeRequest {
	r.filter = &filter
	return r
}
// The desired maximum number of query results per page, e.g., 10. A negative value is interpreted as \&quot;0\&quot;. A value of \&quot;0\&quot; indicates that no model results are to be returned except for \&quot;totalResults\&quot;. 
func (r ApiListResourcesOfTypeRequest) Count(count int64) ApiListResourcesOfTypeRequest {
	r.count = &count
	return r
}
// The 1-based index of the first query result. A value less than 1 SHALL be interpreted as 1. 
func (r ApiListResourcesOfTypeRequest) StartIndex(startIndex int64) ApiListResourcesOfTypeRequest {
	r.startIndex = &startIndex
	return r
}
// A string indicating the attribute whose value SHALL be used to order the returned responses.
func (r ApiListResourcesOfTypeRequest) SortBy(sortBy string) ApiListResourcesOfTypeRequest {
	r.sortBy = &sortBy
	return r
}
// A string indicating the order in which the \&quot;sortBy\&quot; parameter is applied.  Allowed values are \&quot;ascending\&quot; and \&quot;descending\&quot;.
func (r ApiListResourcesOfTypeRequest) SortOrder(sortOrder string) ApiListResourcesOfTypeRequest {
	r.sortOrder = &sortOrder
	return r
}
// A multi-valued list of strings indicating the names of resource attributes to return in the response, overriding the set of attributes that would be returned by default. 
func (r ApiListResourcesOfTypeRequest) Attributes(attributes []string) ApiListResourcesOfTypeRequest {
	r.attributes = &attributes
	return r
}
// A multi-valued list of strings indicating the names of resource attributes to be removed from the default set of attributes to return.  This parameter SHALL have no effect on attributes whose schema \&quot;returned\&quot; setting is \&quot;always\&quot;. 
func (r ApiListResourcesOfTypeRequest) ExcludedAttributes(excludedAttributes []string) ApiListResourcesOfTypeRequest {
	r.excludedAttributes = &excludedAttributes
	return r
}
// a date time indicating that the requested resources should be retrieved from history as how they looked for the specified time. 
func (r ApiListResourcesOfTypeRequest) ForTime(forTime time.Time) ApiListResourcesOfTypeRequest {
	r.forTime = &forTime
	return r
}

func (r ApiListResourcesOfTypeRequest) Execute() (ResourceList, *_nethttp.Response, error) {
	return r.ApiService.ListResourcesOfTypeExecute(r)
}

/*
ListResourcesOfType List resources of a specific type

Retrieve a list of existing resources of a specific type.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appId The app ID that owns the resources
 @param resourceTypes The resource types
 @return ApiListResourcesOfTypeRequest
*/
func (a *ResourcesApiService) ListResourcesOfType(ctx _context.Context, appId string, resourceTypes string) ApiListResourcesOfTypeRequest {
	return ApiListResourcesOfTypeRequest{
		ApiService: a,
		ctx: ctx,
		appId: appId,
		resourceTypes: resourceTypes,
	}
}

// Execute executes the request
//  @return ResourceList
func (a *ResourcesApiService) ListResourcesOfTypeExecute(r ApiListResourcesOfTypeRequest) (ResourceList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  ResourceList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourcesApiService.ListResourcesOfType")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/resources/{appId}/{resourceTypes}"
	localVarPath = strings.Replace(localVarPath, "{"+"appId"+"}", _neturl.PathEscape(parameterToString(r.appId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"resourceTypes"+"}", _neturl.PathEscape(parameterToString(r.resourceTypes, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.filter != nil {
		localVarQueryParams.Add("filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("count", parameterToString(*r.count, ""))
	}
	if r.startIndex != nil {
		localVarQueryParams.Add("startIndex", parameterToString(*r.startIndex, ""))
	}
	if r.sortBy != nil {
		localVarQueryParams.Add("sortBy", parameterToString(*r.sortBy, ""))
	}
	if r.sortOrder != nil {
		localVarQueryParams.Add("sortOrder", parameterToString(*r.sortOrder, ""))
	}
	if r.attributes != nil {
		t := *r.attributes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("attributes", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("attributes", parameterToString(t, "multi"))
		}
	}
	if r.excludedAttributes != nil {
		t := *r.excludedAttributes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("excludedAttributes", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("excludedAttributes", parameterToString(t, "multi"))
		}
	}
	if r.forTime != nil {
		localVarQueryParams.Add("forTime", parameterToString(*r.forTime, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
